import logging
from typing import Optional

import pandas as pd
import pandas_profiling as pp
from pandas_profiling import ProfileReport
import json
import pyarrow.parquet as pq

log = logging.getLogger(__name__)
log.setLevel(logging.INFO)
handler = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
log.addHandler(handler)


def get_source_df(input_file_path: str, file_format: str, separator=',', na_val='') -> Optional[pd.DataFrame]:
    """
    This function read various data source file (e.g. csv, json, parquet), then return a pandas data frame of the
    data source file
    
    :param input_file_path: path of the input file
    :param file_format: file format, only accept csv, json, and parquet
    :param separator: if file is csv, can specify a separator
    :param na_val: if file is csv, can specify a null value identifier
    :return: a pandas dataframe, or none, if the file format is not supported
    """
    if file_format == "csv":
        df = pd.read_csv(input_file_path, sep=separator, na_values=[na_val])
    elif file_format == "json":
        rows = []
        for line in open(input_file_path, 'r'):
            rows.append(json.loads(line))
        df = pd.DataFrame(rows)
        # I don't use df = pd.read_json(input_file_path), because it can't handle null value in json file correctly.

    elif file_format == "parquet":
        table = pq.read_table(input_file_path)
        df = table.to_pandas()
    else:
        log.error("The input data format is not supported")
        df = None
    return df


def generate_report(df: pd.DataFrame, output_path: str, report_name: str, report_title="Profiling Report") -> bool:
    """
    This function generates a data profiling report without metadata and column description

    :param df: input pandas dataframe which we will profile
    :param output_path: output report parent directory
    :param report_name: the name of the output report
    :param report_title: the title of the report, default value is 'Profiling Report'
    :return: return true if the report is generated successfully
    """

    try:
        profile = ProfileReport(df, title=report_title, explorative=True)
        report_full_path = f"{output_path}/{report_name}"
        profile.to_file(report_full_path)
    except Exception as e:
        log.exception(f"Fail to generate report. {e}")
        return False
    else:
        log.info(f"Profiling Report is successfully generated at {report_full_path} ")
        return True


def generate_report_with_meta(df: pd.DataFrame, dataset_metadata: dict, columns_description: dict) -> \
        Optional[pp.ProfileReport]:
    """
    This function generates report with metadata and column description. Check below example for more information about
    the format of metadata and column description


    :param df: input pandas dataframe which we will profile
    :param dataset_metadata:
    :param columns_description:
    :return: return a ProfileReport that can be written in html or json

    Examples:

    dataset_metadata = {
    "description": "This profiling report was generated by using the census dataset.",
    "creator": "toto",
    "author": "toto",
    "copyright_holder": "toto LLC",
    "copyright_year": "2020",
    "url": "http://toto.org"}

    columns_description = {
    "descriptions": {
        "column_name": "column_description",
        ...
        "column_name": "column_description", }
           }

    """
    try:
        profile = ProfileReport(df, title="Agriculture Data", dataset=dataset_metadata,
                                variables=columns_description)
    except Exception as e:
        log.exception(f"Fail to generate report. {e}")
        return None
    else:
        log.info(f"Profiling Report is successfully generated")
        return profile


def main():
    csv_file_path = "../data/adult.csv"
    output_path = "/tmp/report"

    # df = get_source_df(csv_file_path, "csv", ",", na_val="?")
    # print(df.head())
    # if df is not None:
    #     result = generate_report(df, output_path, "report.html")
    #     print(result)
    # else:
    #     print("failed")

    # json_file_path = "../data/adult.json"
    #
    # df1 = get_source_df(json_file_path, "json")
    # print(df1.head())
    # if df1 is not None:
    #     result = generate_report(df1, output_path, "report1.html")
    #     print(result)
    # else:
    #     print("failed")

    parquet_file_path = "../data/adult.snappy.parquet"

    df2 = get_source_df(parquet_file_path, "parquet")
    print(df2.head())
    if df2 is not None:
        result = generate_report(df2, output_path, "report2.html")
        print(result)
    else:
        print("failed")


if __name__ == "__main__":
    main()
